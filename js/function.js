

/**
 * 对象是什么
   怎么创建对象
   对象的使用方法 修改属性、增加属性、执行方法、删除属性、遍历属性。


*/
/**
 * 1、函数是什么 ->函数的由来
 * 2、js中的函数 ->函数的声明方式 命名函数、匿名函数
 * 3、为什么要使用函数 ->使用函数的好处
 * 4、函数的本质 ->函数的二象性
 * 5、函数的传参 ->形参和实参要保持一样吗？ arugments 有什么用？ 它是数组吗 apply 和call呢 ？ protery?
 * 6、函数的返回值 ->返回的类型有哪些  函数能作为返回值返回吗
 * 
 */


 /***
  *                    =====第一部分=====
  * 1、函数是什么?
  * 函数是将实现了某个功能的语句组成的一个代码块，可以一处定义，到处使用。
  * 
  *2、js中的函数

    function add(x,y){
      return x+y;
    }

    function:函数定义关键字 表明定义的是一个函数
    add: 函数名  见名知义 知道这个函数实现的是什么功能
    x,y: 函数参数 由外部传入 js中的形参和实参不一定匹配 形参定义了多个，实参可能一个不传或传多个
    {...}: 大括号里面的部分就是函数的执行体 有局部作用域的功能，这里封装了函数的具体功能。
    return: 函数返回 函数可以有返回值也可以没有返回值 具体看需要

    以上定义的是有函数名的函数，也可以定义匿名函数  比如
    function (x,y){
      return x+y;
    }
    匿名函数一般可用作函数的参数传入或返回值或者不需要函数名调用的地方。

    函数执行的时候发生了什么
    函数调用的时候会创建一个局部的作用域， 同时传参和执行代码。
    当函数执行完毕的时候， 就会销毁所有的局部变量。

    3、使用函数的好处
       3.1 可以将实现相同功能的代码片段封装，以便只定义一次可以到处使用，代码复用
       3.2 隐藏代码的实现细节，提高程序的可读性
       
    4、函数的本质
       4.1 函数就是可以被调用的函数 这是函数最原始的作用
       4.2 函数是对象，它拥有对象所有的一切特性 比如
           4.2.1 函数可以添加属性和方法
           4.2.2 函数本体可以作为对象的值或者数组的值或者赋值给一个变量使用
           4.2.3 函数可以作为函数的参数传入
           4.2.4 函数可以作为函数的返回值返回

     函数名的作用: 函数名就是函数对象的引用变量,函数名对应栈中的位置保存的是函数在堆中定义的起始地址。 通过函数名可以间接引用到函数
     对于匿名函数来说可以赋值给一个变量也可以直接作为变量使用。

     函数名加括号和不加括号的区别
     函数名加括号表示调用函数，如果是不加括号表示引用函数本体(函数定义)。
  * 
  */


  /**
   * 
   *                       =====第二部分=====
   * 
   * 1、函数的三种定义方式
   *    1.1 函数定义的三种方式
   *    1.2 三种方式的各自的优劣
   *    1.3 选择哪种定义方式
   *        1.1.1 函数定义的三种方式
   *          字面量
   *          function add(num1,num2){
   *            return num1+num2;
   *          }
   *         var 赋值表达式
   *         var add = function(num1,num2){
   *          return num1+num2;
   *        }
   *        构造函数式
   *        new Funtion('num1','num2','return num1+num2');
   *     1.1.2 三种方式的优劣
   *        字面量: 直观、易懂。  声明提前
   *        变量式: 适合一次回调函数的写法，直观、简洁
   *        构造函数式: 如果执行语句很多，很笨重，一般不用。
   *        
   *        函数的预解析
   *        ① 当在全局环境中定义了一个函数后，JS解析器在预解析开始就会把函数提到代码最前面，所以就算函数执行在定义后面也不会影响，这里补充一句是只适合与字面量方式定义的函数
   *        ② 如果是变量式定义的函数 如果执行在定义后 那没问题。但如果执行在定义前 因为 var定义的变量会被解析成 undefied，所以执行函数就会报错。
   *          具体见实例
   * 
   *    函数定义的位置
   *   1、全局作用域定义
   *   function add(){
   *   }
   *   2、函数作用域定义
   *   function add(){
   *      fn();
   *    funtion fn(){
   *        fn();
   *        function fn3(){
   *          fn();  
   *          ...
   *        }
   *      ...
   *    }
   *    funtion fn2(){
   *       fn();
   *      ...
   *    }
   *  }
   *  3 if/for块中定义
   *    if(true){
   *      function add(argument){
   *        //body....
   *      }
   *    }else{
   *        function subtract(argument){
   *          //body...
   *        }
   *     }
   *    这里的 add() 和 subtract()函数 虽然是定义在if块中 ，但JS没有块级作用域
   *    所以这两个函数相当于是定义在全局作用域中。会被提到代码的最前面。如果是
   *    依靠分支来执行函数就没有任何效果了。所以不要再代码块中定义函数
   * 
   * 
   *    //对象中定义 作为对象的方法使用
   *     var person = {
   *        'name':'ky',
   *        'age':function setAge(age){
   *            this.age = age;
   *          }
   *    }
   * 
   * 
   * 
   * ---------------------------------------------------------------------------华丽の分界线------------------------------------------------------------
   * 2、函数的调用
   *  2.1 普通函数的调用
   *      function add(num1,num2){
   *        return num1+num2;
   *      }
   *  2.2 匿名函数的调用
   *      function (){
   *        console.log('fn');  
   *      }
   *      var add = function(){
   *       console.log('a'); 
   *     }();
   *  2.3 递归函数的调用
   * 
   * 2.4 方法的调用
   *    var operation { 
   *      add:function(num1,num2){
   *      return num1+num2;
   *    }
   * }
   * 
   *  operation.add();
   * 
   *  document.onclick = function(){
   *    console.log("你点击了");
   *  }
   *  document.onclick();
   * 
   * 对象的属性是合法的变量名什么时候要加引号 什么时候可以不加呢
   * ①可以不用加引号 比如 name 
   * ②如果是不合法的变量名 就需要加引号 比如 &
   *   var obj = {
   *    name = "xiaoming";
   *    '&':function(){
   *      console.log('&');
   *    }
   * }
   * console.log(obj.name);  //正确命名的取法
   * console.log(obj['&']);  //非法的标识符取法
   * 
   * 2.5 方法的链式调用
   * 通过返回this来链式调用  有点像build模式
   * 
   * 2.6 构造函数的调用
   *  function add(){
   *      ...
   * }
   * 
   * 构造函数和普通函数的区别 写法上没有什么区别 区别是调用方式不同
   *    2.6.1 构造函数是通过new的方式来调用
   *    2.6.2 普通函数是通过()来调用 如果写了构造函数但通过()来调用那它就是个普通函数
   *   function Person(){
   *        .....
   *    }
   *    function add(){
   *        ...... 
   *    }
   * 
   *     var person = new Person();  //构造函数的调用
   *     add();  //普通函数的调用
   *
   * 2.7  函数间接调用
   *     function add(){
   *        .....
   *     }
   *     add();
   *     add.call()   //函数自有方法
   *     add.apply();
   *    
   *     apply和call最大的作用就是改变this的指向.
   * 
   * 
   * 总结:
   *     
   *   
   * 
   *-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 华丽の分界线-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   * 3、函数的参数使用
   *  
   *    3.1 参数传递做了什么
   *    函数传参的本质: 把实参的值传递给形参
   *    function add(num1,num2){
   *      return num1+num2;
   *    }
   *    add(1,2)  //函数参数的传递就是把 实参的值赋值给形参  num1 = 1;num2 = 2;
   *    
   * 
   *   参数的值即可以是基本类型的，也可以是引用类型的
   *    3.1.1 如果是基本类型就是把值的副本传递给了形参
   *    3.1.2 如果是引用类型就是把引用地址传递进去了。如果在函数内部改变了引用的内容，那么反应到外部获取到改变的内容。
   *    3.1.3 传入实参的个数可以比形参多也可以比形参少或者相等。两者的个数不一定要匹配。
   *          实参小于形参 可选参数 有些可传可不传
   *          实参大于参数 
   *    
   *   3.2 arguments的作用
   *    1) arguments是每个函数都有的。
   *    2) arguments其实是一个假数组，它的真实面目是这样的,所以它没有数组的方法
   *        {
   *          '0':参数1
   *          '1':参数2
   *           .....
   *        }
   *    3) arguments是和形参一一对应的，如果通过arguments改变它的值，反映到对应的形参上也是改变了的值。所以不要通过arguments来改变值。
   *    4) arguments.callee 指向函数本体 比如
   *      function add(){
   *          console.log('add');
   *          if(arguments === add){
   *              console.log(true)   //这里的arguments.callee就和add是一个意义。
   *          }
   *      }
   *    5) arguments.lenght 是实参的个数
   *       函数名.lenght 是形参的个数
   *      
   *    
   *    3.3 什么东西可以做为参数
   *      3.3.1  什么都不传
   *      function fn(){
   *          ....
   *      }
   * 
   *      3.3.2 数字、字符串、boolean、undefined、null 基本类型都可以作为参数
   *      fn(1,2)、 fn('a') 、fn(true) fn(undefined) 、fn(null) 后面这两种传的很少一般是参数设计的不合理
   * 
   *     3.3.3  引用类型 作为参数
   * 
   *     数组
   *     $.each([1,2,3],function(index,item){
   *        console.log(index);
   *        console.log(item);
   *    });
   * 
   *    对象 
   *      如果一个函数要传递的参数超过三个，那么最好以对象的方式传入。
   * 
   *    函数
   *    setTimeout(function(){
   *      .....
   *    },1000);
   * 
   * 总结: 
   *      1、函数参数的类型
   *      2、参数的个数
   *      3、arguments
   *      4、什么可以做参数
   *-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - 华丽の分界线-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
   * 
   * 4、函数的参数返回值
   * 
   * 
   */