

/* 变量 数据类型 运算符 表达式 语句 */


//【变量】
/* 
What : 变量是保存数据的容器

 var a = 14; 定义了一个变量a  它的值是14 保存在内存中。

 变量命令规则
 变量名: $ _ 字母 数字 ，不能用数字开头  123_a 是不合法的变量名 
 $.clear() //JQuery的写法
 clear()   //字母开头
 _clear() //下划线开头
 关键字: if for
 保留字: class
 
 Note: *变量名最好要见名知义
       *最好不要用拼音来命名
       *要么用驼峰法命名或者下划线来连接 风格要保持一致  buttonConfirm button_confirm
       *i,j,k 一般用于循环内部使用
       *js变量名区分大小写

How : var 关键字用来声明变量 ，每一个变量都一个名字用来对应内存中的一块具体的空间位置(内存地址) 比如  var score = 15 操作变量名就等于在操纵该变量名对应内存地址的空间;
      *var a,b,c;  声明多个变量，变量名之间用逗号来分割，最后用分号结束.


1、数据的类型
  基本类型  null 、undefined、true/false、3.14/3、'love'/"love";
  引用类型  {}、function(){}、[]、date、math、Boolean、Number、String。
----------------------------------------------------------------------------
  区别: * 基本类型的值是不可修改的，而引用类型的值是可以修改的
        * 基本类型调用方法的时候会先转变成对应的包装类型，然后调用包装类型的方法
2、数据的保存
        栈：有序排列、大小固定   基本类型保存在栈中  基本类型按值访问
        堆: 无序排序、大小不固定 引用类型保存在堆中  引用类型按引用访问
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
3、变量比较和值的复制
基本类型的变量比较就是它们在内存的值得比较，比较一般使用"==="比较 
引用类型的变量比较不能单独比较，因为这样比较的是它们在内存的引用地址，如果是两个内容一样的实体变量，它们的内存的引用值肯定是不一样的。所以只能通过比较对象的属性值，for in 变量遍历变量的的属性值.

将一个基本类型的值copy给另一个基本类型变量 是将要copy的变量的值copy一份给copy的变量。比如 a = 4; b =  a;将a的值copy再给b。此时修改b是不会影响a的值的
将一个引用类型的值copy给另一个引用类型变量 是将要copy的引用变量的内存地址给copy的变量，比如 a = {"name":"张山"} b = a; 将a的引用地址给b。此时修改b的值,a获取的值会发生同样变化。
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

4、参数的传递和类型检查

*参数传递

Note: 
0) 基本类型是按值传递，实际上是把值copy一份传入。
1)引用类型是按值传递，但使用的时候是按引用访问。这一点要区分开
 function setName(obj){
       obj.name = "张山";
       obj = {};
       obj.name = "李四";
 }
 var person = {};
 setName(person);
 console.log("person.name"+person.name); //张山


类型检查

typeof 是一个关键字 而不是函数 用来检测变量的类型 同样对于字面量也是一样的
instanceof 用来检测对象类型  
typeof 和 instanceof的区别是 instanceOf用来检测对象的类型 比如
[]数组是对象 用typeof只会告诉是object对象，但不会告诉你是Array对象。但instanceof可以
*instanceof只能和引用类型使用，不能和基本类型使用。
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

5、作用域
 *全局作用域、局部作用域 用两句话总结就是
1)变量的生命周期
   5.1.1 全局变量的生命周期是JS文件的执行期间，只有某个JS的代码全部执行完毕它的生命周期才结束
   5.1.2 局部变量的生命周期就是函数体内，一旦函数执行完毕 变量的生命周期也就结束了
2)访问到变量
   5.2.1 全局变量的可以任何一个地方被访问到
   5.2.2 局部变量只能在函数体执行期间被访问到，一旦函数执行结束，它的生命周期结束，也就不可访问了。局部变量对函数体外是不可见的。

全局作用域；js文件
局部作用域: 主要是函数作用域(函数体内部的执行环境) (js没有块级作用域)

js块级作用域，在if for while等语句中定义的变量 出了块后依旧可用
if(){
      var name = "xm";
}else{
   console.log(name);
}

 6、作用域链
作用域链的形成以及作用
  作用:作用域链是用来查询变量的。
*变量对象: 
 1、全局中定义的方法和变量都是window对象的属性和方法 也就是说window是全局的变量对象
 2、对于函数来说函数体内部也有变量和方法，而函数的变量对象是看不到和不可感知的，但实际上是存在的，
    虽然看不见 但JS引擎在后台处理的时候会用到，是给JS引擎用的，不是给我们用的。

 * 全局中引用一个不存在的变量会报错  如果是通过window.变量名 只会报undefined
 
 作用域链的形成和变量查找
 函数定义的时候会形成一个作用域链，从最外层的window开始，逐个往内层深入，每个函数都有
 自己的变量对象，也会形成自己内部作用域，同时如果函数嵌套函数那么内部的函数又会形成自己的
 作用域，这样知道最后一个函数的作用域形成，从最里层往最外层跳出，可以理解成一个作用域链
 
 变量查找
 在当前函数作用域中查找一个变量时，如果这个变量不存在当前环境，那么就沿着作用域链一级一级往上找(只能往外查不能往里查找)，
 如果找到顶层window还是没有找到抛出错误。

 延长作用域链
 var person = {};
 person.name = "xm"
 person.sex = "male";
 var age = 4;
 with(person){
   name = 'xh';
   sex = 'female'
   age = 5;
 }
 with是的person是在window之前的作用域

-----------------------------------------------------------------------------------
 JS解析过程
      1、预解析
      2、逐行执行代码

7、预解析
 7.1、预解析主要做了什么。
      第一步 查找所有使用var声明的变量并赋值为undefined(先从全局作用域搞起，搞完全局，再把函数中用var声明的变量再搞一次)
      第二步 查找所有全局范围内的function声明的函数直接拷贝，不做处理。
      注意 
          1) 预解析过程中如果声明了多个相同的变量名，那么都是undefined
          2) 预解析过程中如果声明了多个相同名称的函数 以最后声明的那个为主
          3) 预解析过程中如果声明了相同的函数名和变量名 那么变量名就会被忽略。
      
 预解析接下来就是逐行执行代码了。


7.2、不用var命名变量和用var命令变量预解析有什么区别
7.3、同名的变量怎么做预解析、同名的变量和同名函数怎么做预解析  同名的函数怎么做预解析
7.4、预解析和执行有关联吗
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -
8、内存管理
1、什么是标记清除、什么是引用清除 各自有什么优缺点
2、怎样减少内存泄露和溢出的风险

what 内存管理做了什么？
   内存管理主要是收集无用的数据 打个标记 回收清除，释放内存 周而复始。
how  通过什么方式来给无用数据标记
     将离开作用范围的值打上标记，打标记的方式有两种
     1、标记清除 (主要是对离开作用域的值打上标记)
     2、引用计数
why  标记清除为什么比引用清除好
     重复引用会导致引用计数失效，最终内存溢出.
how  怎样去减少内存泄露和溢出的风险？
     1、减少使用全局变量
     2、对于无用的全局变量可以通过置null的方式解除引用。
*/


//总结:
/**
 * 1、变量的本质:保存数据容器
 * 变量的命名规则(区分大小写、不能用数字开头) 好的建议
 * 变量的声明 var声明 和 非var声明  
 * var可以预解析
 * 数据类型 基本类型和引用类型 
 * 基本类型和引用类型的对比 --可以修改和不可以修改  保存位置不一样  栈和堆
 * 数据的copy
 * 
 *  
 * 
 */

